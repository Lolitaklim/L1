
const MathX = (function() {
    // приватные функции

    // вычисление N-го числа в ряду Фибоначчи 
    const nthFibonacci = n => {
        // инициализация первых двух значений ряда
        let a = 0, b = 1;

        // пока порядок числа меньше заданного, обновляем числа перемещая их в последовательности
        for(let i = 2; i < n; i++) [a, b] = [b, a + b];

        return b;
    };

    // вычисление всех чисел в ряду Фибоначчи до числа N
    const seriesFibonacci = n => {
        let a = 0, b = 1;
        // массив для хранения ряда чисел
        let series = [];

        // пока значение числа а в ряду меньше заданного значения
        for (let i = 2; a < n; i++) {
            // добавляем текущее число в массив
            series.push(a);
            [a, b] = [b, a + b];
        }
        return series;
    };

    // является ли число простым
    const isPrime = n => {
        // проходим по всем числам меньших корня заданного, если нет остатка от деления число не простое
        for(let i = 2; i * i <= n; i++) if (n % i === 0) return false;
        return true;        
    }

    // вычисление N-го просто числа
    const nthPrime = n => {
        // начало с первого простого числа, индекс текущего простого числа
        let number = 2, index = 0;
    
        // пока не достигнут нужный индекс
        while(index < n) {
            // увеличиваем индекс, если текущее число простое
            if(isPrime(number)) index++;
            // увеличиваем число, если еще не достигнут нужный индекс
            if(index < n) number++;
        }
        return number;
    }

    // вычисление всех простых чисел до числа N
    const seriesPrime = n => {
        let series = [];

        // проверяем каждое число до n на простоту, добавляем простое число в массив
        for (let i = 2; i < n; i++) if (isPrime(i)) series.push(i);
        return series;
    }

    // Публичные методы
    return { nthFibonacci, seriesFibonacci, nthPrime, seriesPrime };
})();

console.log(MathX.nthFibonacci(17));
console.log(MathX.seriesFibonacci(988)); 
console.log(MathX.nthPrime(4)); 
console.log(MathX.seriesPrime(17)); 


// Замыкание (closure) - это особенность языков программирования, 
// которая позволяет функции сохранять доступ к переменным из окружающей области видимости, 
// в которой они были созданы, даже после того, как эта область видимости завершила свою работу.

// внутри функции, которая создает объект MathX, определены приватные функции,
// они используются только внутри этой области видимости и не доступны извне,
// когда MathX возвращается из этой функции, возвращаемый объект имеет доступ к этим приватным функциям, 
// благодаря замыканию, что позволяет им сохранять доступ к переменным и другим функциям в области видимости MathX.